<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D ä¸°æ»¡åœ£è¯æ ‘ - æ‰‹åŠ¿æ§åˆ¶</title>
    <style>
        body { margin: 0; overflow: hidden; background: #020202; touch-action: none; font-family: sans-serif; }
        #container { width: 100vw; height: 100vh; }
        
        /* æ‘„åƒå¤´é¢„è§ˆï¼šä¿æŒä¸å˜ */
        #video-container { 
            position: absolute; top: 10px; right: 10px; 
            width: 90px; height: 68px; 
            border: 2px solid rgba(255, 215, 0, 0.5); border-radius: 8px; 
            overflow: hidden; transform: scaleX(-1); z-index: 100;
            background: #000;
        }
        video { width: 100%; height: 100%; object-fit: cover; opacity: 0.8; }

        /* UI ä¼˜åŒ–ï¼šå¢å¤§å­—ä½“æå‡æ‰‹æœºé˜…è¯»ä½“éªŒ */
        #ui { 
            position: absolute; bottom: 40px; width: 100%; 
            text-align: center; color: #fff; pointer-events: none; 
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.6);
        }
        #state-text { font-size: 24px; margin: 0; color: gold; letter-spacing: 2px; }
        .hint { font-size: 14px; opacity: 0.9; margin-top: 10px; color: #ccc;}
        
        #loader {
            position: fixed; inset: 0; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000; color: gold; transition: opacity 0.5s;
        }
    </style>
</head>
<body>

<div id="loader">
    <h3 style="letter-spacing: 3px;">ğŸ„ GOLDEN TREE ğŸ„</h3>
    <p>æ­£åœ¨åŠ è½½ AI æ‰‹åŠ¿æ¨¡å‹...</p>
    <p style="font-size: 12px; opacity: 0.7;">è¯·æˆäºˆæ‘„åƒå¤´æƒé™</p>
</div>

<div id="video-container">
    <video id="webcam" autoplay playsinline></video>
</div>

<div id="ui">
    <h2 id="state-text">è¯·ä¸¾èµ·æ‰‹æŒ ğŸ‘‹</h2>
    <div class="hint">ğŸ–ï¸å¼ å¼€ï¼šç‚¸è£‚æ•£å¼€ | âœŠæ¡æ‹³ï¼šèšåˆåœ£è¯æ ‘</div>
</div>

<div id="container"></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@23.1.1/dist/tween.esm.js';

    let scene, camera, renderer, composer, particles;
    let handLandmarker;
    const video = document.getElementById('webcam');
    let currentState = 'FOLD';

    // --- 1. åˆå§‹åŒ– 3D åœºæ™¯ (æ ¸å¿ƒä¿®æ”¹åŒºåŸŸ) ---
    function initScene() {
        scene = new THREE.Scene();
        // è°ƒæ•´ç›¸æœºè·ç¦»ï¼Œç¦»å¾—ç¨è¿œä¸€ç‚¹ä»¥è§‚å¯Ÿå…¨è²Œ
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 28; 

        renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // é™åˆ¶åƒç´ æ¯”ï¼Œé˜²æ­¢é«˜åˆ†å±æ‰‹æœºå¡é¡¿ï¼ŒåŒæ—¶è®©ç²’å­çœ‹èµ·æ¥æ›´å¤§
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0));
        document.getElementById('container').appendChild(renderer.domElement);

        // å¢å¼ºè¾‰å…‰ï¼šæå‡å¼ºåº¦å’ŒåŠå¾„ï¼Œè¥é€ èŠ‚æ—¥æ°›å›´
        const renderScene = new RenderPass(scene, camera);
        // strength 1.0 -> 1.2, radius 0.4 -> 0.6
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.6, 0.7);
        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // ç¨å¾®å¢åŠ ç²’å­æ•°é‡ä»¥æå‡å¯†åº¦
        const count = 1600; 
        const geometry = new THREE.BufferGeometry();
        const pos = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        // è°ƒæ•´é…è‰²æ¯”ä¾‹ï¼šæ›´å¤šé‡‘è‰²å’Œçº¢è‰²ï¼Œæ›´æœ‰èŠ‚æ—¥æ„Ÿ
        const palette = [
            new THREE.Color(0xffd700), // é‡‘
            new THREE.Color(0xffd700), // é‡‘ (åŠ å€æƒé‡)
            new THREE.Color(0xbc131f), // çº¢
            new THREE.Color(0x0f3b23)  // æ·±ç»¿
        ];

        for (let i = 0; i < count; i++) {
            // æ•£å¼€çŠ¶æ€çš„èŒƒå›´åŠ å¤§
            pos[i * 3] = (Math.random() - 0.5) * 40;
            pos[i * 3 + 1] = (Math.random() - 0.5) * 40;
            pos[i * 3 + 2] = (Math.random() - 0.5) * 40;
            
            const c = palette[Math.floor(Math.random() * palette.length)];
            colors[i * 3] = c.r; colors[i * 3 + 1] = c.g; colors[i * 3 + 2] = c.b;
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // --- æ ¸å¿ƒä¿®æ”¹ï¼šShader ---
        const mat = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 }, uProgress: { value: 0 } },
            vertexShader: `
                varying vec3 vColor;
                uniform float uTime;
                uniform float uProgress;

                // ç®€å•çš„ä¼ªéšæœºå‡½æ•°
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                void main() {
                    vColor = color;

                    // --- æ–°çš„åœ£è¯æ ‘å½¢æ€è®¡ç®— ---
                    // å°†åŸå§‹Yåæ ‡æ˜ å°„åˆ° 0.0 (åº•éƒ¨) åˆ° 1.0 (é¡¶éƒ¨) çš„èŒƒå›´
                    float hMap = smoothstep(-20.0, 20.0, position.y);
                    
                    // æ ‘çš„å®é™…é«˜åº¦èŒƒå›´ï¼šä» Y=-12 åˆ° Y=10
                    float treeH = hMap * 22.0 - 12.0;

                    // åœ†é”¥ä½“åŠå¾„æ§åˆ¶ï¼šåº•éƒ¨å®½ï¼Œé¡¶éƒ¨å°–
                    // baseRadius = 9.0 (åº•éƒ¨æœ€å¤§åŠå¾„)
                    float baseRadius = (1.0 - hMap) * 9.0;
                    
                    // åˆ©ç”¨åŸå§‹ä½ç½®ä¿¡æ¯æ·»åŠ å™ªç‚¹ï¼Œè®©ç²’å­åˆ†å¸ƒåœ¨åœ†é”¥ä½“å†…éƒ¨ï¼Œè€Œä¸æ˜¯åªåœ¨è¡¨é¢
                    // noise èŒƒå›´å¤§è‡´åœ¨ 0.5 åˆ° 1.5 ä¹‹é—´
                    float noiseR = random(position.xz) * 1.0 + 0.5; 
                    float r = baseRadius * noiseR;
                    // ç¡®ä¿é¡¶éƒ¨æ”¶å°–
                    r *= smoothstep(1.0, 0.9, hMap);

                    // èºæ—‹è§’åº¦ï¼šéšé«˜åº¦å’Œæ—¶é—´å˜åŒ–
                    float ang = atan(position.x, position.z) + hMap * 10.0 + uTime * 0.8;

                    // è®¡ç®—åˆæ‹¢æ€ä½ç½®
                    vec3 foldPos = vec3(sin(ang) * r, treeH, cos(ang) * r);
                    
                    // æ··åˆä½ç½®çŠ¶æ€
                    vec3 finalPos = mix(foldPos, position, uProgress);

                    vec4 mv = modelViewMatrix * vec4(finalPos, 1.0);
                    
                    // --- æ ¸å¿ƒä¿®æ”¹ï¼šæ˜¾è‘—å¢å¤§ç²’å­å°ºå¯¸ ---
                    // åŸºå‡†å°ºå¯¸ä» 15.0 æå‡åˆ° 80.0
                    // å¢åŠ  max(6.0, ...) ç¡®ä¿è¿œå¤„æˆ–é«˜åˆ†å±ä¸Šè‡³å°‘æœ‰ 6åƒç´ å¤§å°
                    gl_PointSize = max(6.0, (80.0 / -mv.z));
                    
                    gl_Position = projectionMatrix * mv;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                void main() {
                    // å°†æ–¹å½¢ç‚¹è£åˆ‡æˆåœ†å½¢ï¼Œè¾¹ç¼˜æŸ”åŒ–
                    float d = length(gl_PointCoord - 0.5);
                    if(d > 0.5) discard;
                    // ç®€å•çš„å¾„å‘æ¸å˜è®©ç²’å­çœ‹èµ·æ¥æ›´åƒå‘å…‰çƒä½“
                    float alpha = smoothstep(0.5, 0.3, d);
                    gl_FragColor = vec4(vColor, alpha);
                }
            `,
            vertexColors: true,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false // å…³é—­æ·±åº¦å†™å…¥ä»¥è·å¾—æ›´å¥½çš„å åŠ å‘å…‰æ•ˆæœ
        });

        particles = new THREE.Points(geometry, mat);
        scene.add(particles);
    }

    // --- 2. åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ« (ä¿æŒä¸å˜ï¼Œå¢åŠ Loadingéšè—é€»è¾‘) ---
    async function initAI() {
        try {
            const vision = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0");
            const filesetResolver = await vision.FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await vision.HandLandmarker.createFromOptions(filesetResolver, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO", numHands: 1
            });
            
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user", width: 320, height: 240 } });
            video.srcObject = stream;
            video.onloadeddata = () => {
                const loader = document.getElementById('loader');
                loader.style.opacity = '0';
                setTimeout(() => loader.remove(), 500);
                predict();
            };
        } catch (e) {
            document.getElementById('loader').innerHTML = `<p style="color:red">åˆå§‹åŒ–å¤±è´¥: ${e.message}</p><p>è¯·æ£€æŸ¥æ‘„åƒå¤´æƒé™æˆ–ç½‘ç»œ</p>`;
        }
    }

    async function predict() {
        if (handLandmarker && video.currentTime > 0) {
            const results = handLandmarker.detectForVideo(video, performance.now());
            if (results.landmarks && results.landmarks.length > 0) {
                updateLogic(results.landmarks[0]);
            }
        }
        requestAnimationFrame(predict);
    }

    function updateLogic(landmarks) {
        // è®¡ç®—é£ŸæŒ‡å°–(8)åˆ°æŒå¿ƒ(0)çš„è·ç¦»æ¥åˆ¤æ–­æ‰‹æŒå¼€åˆ
        const dist = Math.hypot(landmarks[8].x - landmarks[0].x, landmarks[8].y - landmarks[0].y);
        
        // è°ƒæ•´äº†é˜ˆå€¼ä»¥é€‚åº”ä¸åŒæ‰‹å‹
        if (dist < 0.3 && currentState !== 'FOLD') {
            triggerTransition(0); // åˆæ‹¢
            currentState = 'FOLD';
            document.getElementById('state-text').innerText = "ğŸ„ çŠ¶æ€ï¼šèšåˆåœ£è¯æ ‘ (æ¡æ‹³)";
        } else if (dist > 0.45 && currentState !== 'SCATTER') {
            triggerTransition(1); // æ•£å¼€
            currentState = 'SCATTER';
            document.getElementById('state-text').innerText = "âœ¨ çŠ¶æ€ï¼šç‚¸è£‚æ•£å¼€ (å¼ æ‰‹)";
        }

        // æ—‹è½¬æ§åˆ¶ï¼šä½¿ç”¨æ‰‹æŒä¸­å¿ƒçš„Xåæ ‡
        const handX = (landmarks[0].x - 0.5) * 3; // å¢åŠ çµæ•åº¦
        // å¹³æ»‘æ—‹è½¬
        scene.rotation.y += (handX * 0.3 - scene.rotation.y) * 0.08;
    }

    function triggerTransition(val) {
        new TWEEN.Tween(particles.material.uniforms.uProgress)
            .to({ value: val }, 1200) // ç¨å¾®å»¶é•¿è¿‡æ¸¡æ—¶é—´ï¼Œçœ‹èµ·æ¥æ›´é­”å¹»
            .easing(TWEEN.Easing.Quadratic.InOut)
            .start();
    }

    function animate(time) {
        requestAnimationFrame(animate);
        TWEEN.update(time);
        if(particles) {
            particles.material.uniforms.uTime.value = time * 0.0005;
            // åˆæ‹¢çŠ¶æ€ä¸‹æ·»åŠ ç¼“æ…¢è‡ªè½¬
            if (currentState === 'FOLD') {
                 particles.rotation.y += 0.002;
            }
        }
        composer.render();
    }

    initScene();
    initAI();
    animate();

    window.onresize = () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    };
</script>
</body>
</html>
